From a9a3459502d893a08b297475015971c588511211 Mon Sep 17 00:00:00 2001
From: MWCLabs <info@mwclabs.com>
Date: Sat, 20 Dec 2025 23:52:24 -0500
Subject: [PATCH] net: ipv4: add sysctl to toggle TCP ISN generation

Signed-off-by: MWCLabs <info@mwclabs.com>
---
 include/net/netns/ipv4.h   |  3 +++
 net/core/secure_seq.c      | 18 +++++++++++++++---
 net/ipv4/sysctl_net_ipv4.c | 11 +++++++++++
 3 files changed, 29 insertions(+), 3 deletions(-)

diff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h
index 6373e3f17..ecdc7ec7b 100644
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -72,6 +72,9 @@ struct netns_ipv4 {
 	u8 sysctl_ip_fwd_use_pmtu;
 	__cacheline_group_end(netns_ipv4_read_tx);
 
+	/* TCP-wide (IPv4 + IPv6) ISN randomization */
+	int sysctl_tcp_random_isn;
+
 	/* TXRX readonly hotpath cache lines */
 	__cacheline_group_begin(netns_ipv4_read_txrx);
 	u8 sysctl_tcp_moderate_rcvbuf;
diff --git a/net/core/secure_seq.c b/net/core/secure_seq.c
index 9a3965680..f03a893fc 100644
--- a/net/core/secure_seq.c
+++ b/net/core/secure_seq.c
@@ -14,6 +14,8 @@
 #include <linux/net.h>
 #include <linux/siphash.h>
 #include <net/secure_seq.h>
+#include <net/net_namespace.h>
+#include <net/netns/ipv4.h>
 
 #if IS_ENABLED(CONFIG_IPV6) || IS_ENABLED(CONFIG_INET)
 #include <linux/in6.h>
@@ -73,7 +75,7 @@ u32 secure_tcpv6_ts_off(const struct net *net,
 }
 EXPORT_IPV6_MOD(secure_tcpv6_ts_off);
 
-u32 secure_tcpv6_seq(const __be32 *saddr, const __be32 *daddr,
+noinline u32 secure_tcpv6_seq(const __be32 *saddr, const __be32 *daddr,
 		     __be16 sport, __be16 dport)
 {
 	const struct {
@@ -89,10 +91,15 @@ u32 secure_tcpv6_seq(const __be32 *saddr, const __be32 *daddr,
 	};
 	u32 hash;
 
-	net_secret_init();
+	if (READ_ONCE(init_net.ipv4.sysctl_tcp_random_isn)) {
+	get_random_bytes(((char *)&hash), sizeof(u32));
+	return hash;
+	} else {
+		net_secret_init();
 	hash = siphash(&combined, offsetofend(typeof(combined), dport),
 		       &net_secret);
 	return seq_scale(hash);
+	}
 }
 EXPORT_SYMBOL(secure_tcpv6_seq);
 
@@ -133,16 +140,21 @@ u32 secure_tcp_ts_off(const struct net *net, __be32 saddr, __be32 daddr)
  * it would be easy enough to have the former function use siphash_4u32, passing
  * the arguments as separate u32.
  */
-u32 secure_tcp_seq(__be32 saddr, __be32 daddr,
+noinline u32 secure_tcp_seq(__be32 saddr, __be32 daddr,
 		   __be16 sport, __be16 dport)
 {
 	u32 hash;
 
+	if (READ_ONCE(init_net.ipv4.sysctl_tcp_random_isn)) {
+	get_random_bytes(((char *)&hash), sizeof(u32));
+	return hash;
+	} else {
 	net_secret_init();
 	hash = siphash_3u32((__force u32)saddr, (__force u32)daddr,
 			    (__force u32)sport << 16 | (__force u32)dport,
 			    &net_secret);
 	return seq_scale(hash);
+	}
 }
 EXPORT_SYMBOL_GPL(secure_tcp_seq);
 
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 3a43010d7..df0f732ee 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -1593,6 +1593,15 @@ static struct ctl_table ipv4_net_table[] = {
 		.extra1		= SYSCTL_ONE_THOUSAND,
 		.extra2		= &tcp_rto_max_max,
 	},
+	{
+		.procname	= "tcp_random_isn",
+		.data		= &init_net.ipv4.sysctl_tcp_random_isn,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
 };
 
 static __net_init int ipv4_sysctl_init_net(struct net *net)
@@ -1634,6 +1643,8 @@ static __net_init int ipv4_sysctl_init_net(struct net *net)
 
 	proc_fib_multipath_hash_set_seed(net, 0);
 
+	net->ipv4.sysctl_tcp_random_isn = 0;
+
 	return 0;
 
 err_ports:
-- 
2.39.5

